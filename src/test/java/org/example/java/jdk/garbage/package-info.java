package org.example.java.jdk.garbage;
/**
 * 判断是否需要回收：
 * 1、引用计数算法
 *    存在循环引用。
 * 2、可达性分析算法
 *  a、在虚拟机栈引用的对象。
 *  b、在方法区中类静态属性引用的对象。
 *  c、在方法区中常量引用的对象。
 *  d、在本地方法栈JNI引用的对象。
 *  e、Java虚拟机内部的引用。
 */

/**
 * 垃圾收集算法
 * 1、分代收集理论：
 *  a、弱分代假说
 *     绝大多数对象都是朝生夕灭的。
 *  b、强分代假说
 *     熬过越多次垃圾收集过程的对象就越难以消亡。
 *  c、跨代引用假说
 *     跨代引用相对同代引用来说仅占极少数。。
 *  2、标记-清除算法
 *     首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象。标记过程就是对象是否属于垃圾的判定过程。
 *     缺点：执行效率不稳定、内存空间碎片化。
 *  3、标记-复制算法
 *     将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块内存用完了就将还存活的对象复制到另外一块上面，然后再把已使用过的内存空间一
 *  次清理掉。
 *     缺点：如果多数对象都是存活的，移动对象将产生大量开销。可用内存只有原来的一半。
 *  4、标记-整理算法
 *     首先标记出所有需要回收的对象，在标记完成后，让所有存活的对象都向内存空间一端移动，然后清理掉边界以外的内存。
 *     缺点：如果多数对象都是存货的，移动对象将产生大量开销。
 */